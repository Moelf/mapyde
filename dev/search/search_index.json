{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"mapyde \u00b6 CI/CD Docs Package Meta MaPyDe stands for MadGraph-Pythia-Delphes which is a utility that allows one to run all of the various HEP toolings or chain them together and perform a quick analysis with the results, such as running CERN ATLAS SimpleAnalysis or pyhf. Features \u00b6 Multiple backends supported docker singularity apptainer Easy configuration with sensible defaults Usable CLI relying on a single config file License \u00b6 mapyde is distributed under the terms of the Apache 2.0 license. Navigation \u00b6 Documentation for specific MAJOR.MINOR versions can be chosen by using the dropdown on the top of every page. The dev version reflects changes that have not yet been released. Also, desktop readers can use special keyboard shortcuts: Keys Action , (comma) p Navigate to the \"previous\" page . (period) n Navigate to the \"next\" page / s Display the search modal","title":"About"},{"location":"#mapyde","text":"CI/CD Docs Package Meta MaPyDe stands for MadGraph-Pythia-Delphes which is a utility that allows one to run all of the various HEP toolings or chain them together and perform a quick analysis with the results, such as running CERN ATLAS SimpleAnalysis or pyhf.","title":"mapyde"},{"location":"#features","text":"Multiple backends supported docker singularity apptainer Easy configuration with sensible defaults Usable CLI relying on a single config file","title":"Features"},{"location":"#license","text":"mapyde is distributed under the terms of the Apache 2.0 license.","title":"License"},{"location":"#navigation","text":"Documentation for specific MAJOR.MINOR versions can be chosen by using the dropdown on the top of every page. The dev version reflects changes that have not yet been released. Also, desktop readers can use special keyboard shortcuts: Keys Action , (comma) p Navigate to the \"previous\" page . (period) n Navigate to the \"next\" page / s Display the search modal","title":"Navigation"},{"location":"install/","text":"Installation \u00b6 pip \u00b6 mapyde is available on PyPI and can be installed with pip . pip install mapyde Warning This method modifies the Python environment in which you choose to install. Consider instead using pipx or virtual environments to avoid dependency conflicts. pipx \u00b6 pipx allows for the global installation of Python applications in isolated environments. pipx install mapyde virtual environment \u00b6 python -m venv venv source venv/bin/activate python -m pip install mapyde Conda \u00b6 See the feedstock for more details. conda install -c conda-forge mapyde or with mamba : mamba install mapyde Warning This method modifies the Conda environment in which you choose to install. Consider instead using pipx or condax to avoid dependency conflicts.","title":"Installation"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#pip","text":"mapyde is available on PyPI and can be installed with pip . pip install mapyde Warning This method modifies the Python environment in which you choose to install. Consider instead using pipx or virtual environments to avoid dependency conflicts.","title":"pip"},{"location":"install/#pipx","text":"pipx allows for the global installation of Python applications in isolated environments. pipx install mapyde","title":"pipx"},{"location":"install/#virtual-environment","text":"python -m venv venv source venv/bin/activate python -m pip install mapyde","title":"virtual environment"},{"location":"install/#conda","text":"See the feedstock for more details. conda install -c conda-forge mapyde or with mamba : mamba install mapyde Warning This method modifies the Conda environment in which you choose to install. Consider instead using pipx or condax to avoid dependency conflicts.","title":"Conda"},{"location":"intro/","text":"Introduction \u00b6 Configuration \u00b6 All project-specific configuration recognized by mapyde can be defined in a custom user.toml : default ewkinos sleptons [base] path = \"/data/users/{{USER}}/SUSY\" output = \"mytag\" template = \"{{MAPYDE_TEMPLATES}}/defaults.toml\" [madgraph.proc] name = \"charginos\" card = \"{{madgraph['proc']['name']}}\" [madgraph.masses] MN1 = 100 MC1 = 150 [base] path = \"/data/users/{{USER}}/SUSY\" output = \"mytag\" template = \"{{MAPYDE_TEMPLATES}}/ewkinos.toml\" [madgraph.proc] name = \"isr2L\" card = \"{{madgraph['proc']['name']}}\" [madgraph.masses] MN2 = 250 MC1 = 250 MN1 = 240 [base] path = \"/data/users/{{USER}}/SUSY\" output = \"mytag\" template = \"{{MAPYDE_TEMPLATES}}/sleptons.toml\" [madgraph.proc] name = \"isrslep\" card = \"{{madgraph['proc']['name']}}\" [madgraph.masses] MSLEP = 250 MN1 = 240 Tip This is all highly customizable with the usage of templates to make it easier to inherit a convenient set of defaults for which you can override.","title":"Introduction"},{"location":"intro/#introduction","text":"","title":"Introduction"},{"location":"intro/#configuration","text":"All project-specific configuration recognized by mapyde can be defined in a custom user.toml : default ewkinos sleptons [base] path = \"/data/users/{{USER}}/SUSY\" output = \"mytag\" template = \"{{MAPYDE_TEMPLATES}}/defaults.toml\" [madgraph.proc] name = \"charginos\" card = \"{{madgraph['proc']['name']}}\" [madgraph.masses] MN1 = 100 MC1 = 150 [base] path = \"/data/users/{{USER}}/SUSY\" output = \"mytag\" template = \"{{MAPYDE_TEMPLATES}}/ewkinos.toml\" [madgraph.proc] name = \"isr2L\" card = \"{{madgraph['proc']['name']}}\" [madgraph.masses] MN2 = 250 MC1 = 250 MN1 = 240 [base] path = \"/data/users/{{USER}}/SUSY\" output = \"mytag\" template = \"{{MAPYDE_TEMPLATES}}/sleptons.toml\" [madgraph.proc] name = \"isrslep\" card = \"{{madgraph['proc']['name']}}\" [madgraph.masses] MSLEP = 250 MN1 = 240 Tip This is all highly customizable with the usage of templates to make it easier to inherit a convenient set of defaults for which you can override.","title":"Configuration"},{"location":"cli/about/","text":"About \u00b6","title":"About"},{"location":"cli/about/#about","text":"","title":"About"},{"location":"cli/reference/","text":"mapyde \u00b6 Manage top-level options Usage: mapyde [OPTIONS] COMMAND [ARGS]... Options: --version Print the current version. --prefix [data|cards|likelihoods|scripts|templates] Print the path prefix for data files. --install-completion [bash|zsh|fish|powershell|pwsh] Install completion for the specified shell. --show-completion [bash|zsh|fish|powershell|pwsh] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit. mapyde config \u00b6 Usage: mapyde config [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. mapyde config generate-mg5 \u00b6 Generate the madgraph configurations and write to local disk. Usage: mapyde config generate-mg5 [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit. mapyde config parse \u00b6 Parse the configuration file and print to screen. Usage: mapyde config parse [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit. mapyde run \u00b6 Usage: mapyde run [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. mapyde run all \u00b6 Run madgraph, delphes, analysis, and pyhf. Usage: mapyde run all [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit. mapyde run analysis \u00b6 Run analysis. Usage: mapyde run analysis [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit. mapyde run delphes \u00b6 Run delphes. Usage: mapyde run delphes [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit. mapyde run madgraph \u00b6 Run madgraph. Usage: mapyde run madgraph [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit. mapyde run pyhf \u00b6 Run pyhf. Usage: mapyde run pyhf [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit. mapyde run root2hdf5 \u00b6 Transform from .root to .hdf5 format. Usage: mapyde run root2hdf5 [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit. mapyde run sa2json \u00b6 Run sa2json. Usage: mapyde run sa2json [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit. mapyde run sherpa \u00b6 Run Sherpa. Usage: mapyde run sherpa [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit. mapyde run simpleanalysis \u00b6 Run simpleanalysis (ATLAS tool) Usage: mapyde run simpleanalysis [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit.","title":"Reference"},{"location":"cli/reference/#mapyde","text":"Manage top-level options Usage: mapyde [OPTIONS] COMMAND [ARGS]... Options: --version Print the current version. --prefix [data|cards|likelihoods|scripts|templates] Print the path prefix for data files. --install-completion [bash|zsh|fish|powershell|pwsh] Install completion for the specified shell. --show-completion [bash|zsh|fish|powershell|pwsh] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit.","title":"mapyde"},{"location":"cli/reference/#mapyde-config","text":"Usage: mapyde config [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit.","title":"config"},{"location":"cli/reference/#mapyde-config-generate-mg5","text":"Generate the madgraph configurations and write to local disk. Usage: mapyde config generate-mg5 [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit.","title":"generate-mg5"},{"location":"cli/reference/#mapyde-config-parse","text":"Parse the configuration file and print to screen. Usage: mapyde config parse [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit.","title":"parse"},{"location":"cli/reference/#mapyde-run","text":"Usage: mapyde run [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit.","title":"run"},{"location":"cli/reference/#mapyde-run-all","text":"Run madgraph, delphes, analysis, and pyhf. Usage: mapyde run all [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit.","title":"all"},{"location":"cli/reference/#mapyde-run-analysis","text":"Run analysis. Usage: mapyde run analysis [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit.","title":"analysis"},{"location":"cli/reference/#mapyde-run-delphes","text":"Run delphes. Usage: mapyde run delphes [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit.","title":"delphes"},{"location":"cli/reference/#mapyde-run-madgraph","text":"Run madgraph. Usage: mapyde run madgraph [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit.","title":"madgraph"},{"location":"cli/reference/#mapyde-run-pyhf","text":"Run pyhf. Usage: mapyde run pyhf [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit.","title":"pyhf"},{"location":"cli/reference/#mapyde-run-root2hdf5","text":"Transform from .root to .hdf5 format. Usage: mapyde run root2hdf5 [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit.","title":"root2hdf5"},{"location":"cli/reference/#mapyde-run-sa2json","text":"Run sa2json. Usage: mapyde run sa2json [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit.","title":"sa2json"},{"location":"cli/reference/#mapyde-run-sherpa","text":"Run Sherpa. Usage: mapyde run sherpa [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit.","title":"sherpa"},{"location":"cli/reference/#mapyde-run-simpleanalysis","text":"Run simpleanalysis (ATLAS tool) Usage: mapyde run simpleanalysis [OPTIONS] FILENAME Options: FILENAME [required] --help Show this message and exit.","title":"simpleanalysis"},{"location":"meta/authors/","text":"Authors \u00b6 Maintainers \u00b6 Mike Hance Giordon Stark Contributors \u00b6 Be Our First!","title":"Authors"},{"location":"meta/authors/#authors","text":"","title":"Authors"},{"location":"meta/authors/#maintainers","text":"Mike Hance Giordon Stark","title":"Maintainers"},{"location":"meta/authors/#contributors","text":"Be Our First!","title":"Contributors"},{"location":"meta/faq/","text":"FAQ \u00b6 Backends \u00b6 Q : What backends do you support? A : So far: singularity, apptainer, and docker. Potpourri \u00b6 Q : Why is the FAQ empty? A : We're still working on fleshing it out. Check back soon. In the meantime, open a discussion or file an issue .","title":"FAQ"},{"location":"meta/faq/#faq","text":"","title":"FAQ"},{"location":"meta/faq/#backends","text":"Q : What backends do you support? A : So far: singularity, apptainer, and docker.","title":"Backends"},{"location":"meta/faq/#potpourri","text":"Q : Why is the FAQ empty? A : We're still working on fleshing it out. Check back soon. In the meantime, open a discussion or file an issue .","title":"Potpourri"},{"location":"reference/mapyde/","text":"mapyde \u00b6 Copyright \u00a9 2022 Michael Hance and Giordon Stark. All rights reserved. mapyde: A great package.","title":"mapyde"},{"location":"reference/mapyde/#mapyde","text":"Copyright \u00a9 2022 Michael Hance and Giordon Stark. All rights reserved. mapyde: A great package.","title":"mapyde"},{"location":"reference/mapyde/container/","text":"container \u00b6 Core Container functionality for managing OCI images. Container \u00b6 Container ( * , image : str , user : T . Optional [ int ] = None , group : T . Optional [ int ] = None , mounts : T . Optional [ list [ tuple [ PathOrStr , PathOrStr ]]] = None , cwd : T . Optional [ PathOrStr ] = '/tmp' , engine : ContainerEngine = 'docker' , name : T . Optional [ str ] = None , stdout : T . Optional [ T . Union [ T . IO [ bytes ], T . IO [ str ]]] = None , output_path : T . Optional [ Path ] = None , logs_path : T . Optional [ PathOrStr ] = None , additional_options : T . Optional [ list [ str ]] = None ) An object that represents a running OCI container. Source code in mapyde/container.py def __init__ ( self , * , image : str , user : T . Optional [ int ] = None , group : T . Optional [ int ] = None , mounts : T . Optional [ list [ tuple [ PathOrStr , PathOrStr ]]] = None , cwd : T . Optional [ PathOrStr ] = \"/tmp\" , engine : ContainerEngine = \"docker\" , name : T . Optional [ str ] = None , stdout : T . Optional [ T . Union [ T . IO [ bytes ], T . IO [ str ]]] = None , output_path : T . Optional [ Path ] = None , logs_path : T . Optional [ PathOrStr ] = None , additional_options : T . Optional [ list [ str ]] = None , ): if not image : raise ValueError ( \"Must specify an image to run.\" ) try : subprocess . run ([ \"bash\" , \"-c\" , f \"hash { engine } \" ], check = True ) except subprocess . CalledProcessError as err : raise OSError ( f \" { engine } does not exist on your system.\" ) from err self . image = image self . user = user or os . geteuid () self . group = group or os . getegid () self . mounts = mounts or [] self . cwd = cwd self . engine = engine self . name = name self . stdin_config = subprocess . PIPE self . stdout_config = stdout or subprocess . PIPE self . stderr_config = subprocess . STDOUT self . output_path = ( output_path or Path ()) . resolve () self . logs_path = logs_path self . additional_options = additional_options or [] self . output_path . mkdir ( parents = True , exist_ok = True ) for host , container in self . mounts : if not Path ( container ) . is_absolute (): raise ValueError ( f \"The mount { host } : { container } does not point to an absolute path in the container.\" ) call \u00b6 call ( args : bytes , cwd : PathOrStr | None = None , env : dict [ str , str ] | None = None ) -> tuple [ bytes , bytes ] Execute the provided command in the container. A smarter version of Container.process.communicate(args). Optionally change the current working directory (cwd) and set some environment variables. Source code in mapyde/container.py def call ( self , args : bytes , cwd : PathOrStr | None = None , env : dict [ str , str ] | None = None , ) -> tuple [ bytes , bytes ]: \"\"\" Execute the provided command in the container. A smarter version of Container.process.communicate(args). Optionally change the current working directory (cwd) and set some environment variables. \"\"\" if cwd is None : cwd = self . cwd chdir = \"\" if cwd : # singularity/apptainer mount host $TMPDIR into /tmp which might be # unexpectedly full of files so make an empty temporary directory chdir = \"cd $(mktemp -d)\" if cwd == \"/tmp\" else f \"cd { cwd } \" env_assignments = ( \" \" . join ( f \" { shlex . quote ( k ) } = { shlex . quote ( v ) } \" for k , v in env . items ()) if env is not None else \"\" ) command = bytes ( f \"\"\" { chdir } env { env_assignments } { args . decode () } \"\"\" , \"utf-8\" , ) return self . process . communicate ( command )","title":"container"},{"location":"reference/mapyde/container/#mapyde.container","text":"Core Container functionality for managing OCI images.","title":"container"},{"location":"reference/mapyde/container/#mapyde.container.Container","text":"Container ( * , image : str , user : T . Optional [ int ] = None , group : T . Optional [ int ] = None , mounts : T . Optional [ list [ tuple [ PathOrStr , PathOrStr ]]] = None , cwd : T . Optional [ PathOrStr ] = '/tmp' , engine : ContainerEngine = 'docker' , name : T . Optional [ str ] = None , stdout : T . Optional [ T . Union [ T . IO [ bytes ], T . IO [ str ]]] = None , output_path : T . Optional [ Path ] = None , logs_path : T . Optional [ PathOrStr ] = None , additional_options : T . Optional [ list [ str ]] = None ) An object that represents a running OCI container. Source code in mapyde/container.py def __init__ ( self , * , image : str , user : T . Optional [ int ] = None , group : T . Optional [ int ] = None , mounts : T . Optional [ list [ tuple [ PathOrStr , PathOrStr ]]] = None , cwd : T . Optional [ PathOrStr ] = \"/tmp\" , engine : ContainerEngine = \"docker\" , name : T . Optional [ str ] = None , stdout : T . Optional [ T . Union [ T . IO [ bytes ], T . IO [ str ]]] = None , output_path : T . Optional [ Path ] = None , logs_path : T . Optional [ PathOrStr ] = None , additional_options : T . Optional [ list [ str ]] = None , ): if not image : raise ValueError ( \"Must specify an image to run.\" ) try : subprocess . run ([ \"bash\" , \"-c\" , f \"hash { engine } \" ], check = True ) except subprocess . CalledProcessError as err : raise OSError ( f \" { engine } does not exist on your system.\" ) from err self . image = image self . user = user or os . geteuid () self . group = group or os . getegid () self . mounts = mounts or [] self . cwd = cwd self . engine = engine self . name = name self . stdin_config = subprocess . PIPE self . stdout_config = stdout or subprocess . PIPE self . stderr_config = subprocess . STDOUT self . output_path = ( output_path or Path ()) . resolve () self . logs_path = logs_path self . additional_options = additional_options or [] self . output_path . mkdir ( parents = True , exist_ok = True ) for host , container in self . mounts : if not Path ( container ) . is_absolute (): raise ValueError ( f \"The mount { host } : { container } does not point to an absolute path in the container.\" )","title":"Container"},{"location":"reference/mapyde/container/#mapyde.container.Container.call","text":"call ( args : bytes , cwd : PathOrStr | None = None , env : dict [ str , str ] | None = None ) -> tuple [ bytes , bytes ] Execute the provided command in the container. A smarter version of Container.process.communicate(args). Optionally change the current working directory (cwd) and set some environment variables. Source code in mapyde/container.py def call ( self , args : bytes , cwd : PathOrStr | None = None , env : dict [ str , str ] | None = None , ) -> tuple [ bytes , bytes ]: \"\"\" Execute the provided command in the container. A smarter version of Container.process.communicate(args). Optionally change the current working directory (cwd) and set some environment variables. \"\"\" if cwd is None : cwd = self . cwd chdir = \"\" if cwd : # singularity/apptainer mount host $TMPDIR into /tmp which might be # unexpectedly full of files so make an empty temporary directory chdir = \"cd $(mktemp -d)\" if cwd == \"/tmp\" else f \"cd { cwd } \" env_assignments = ( \" \" . join ( f \" { shlex . quote ( k ) } = { shlex . quote ( v ) } \" for k , v in env . items ()) if env is not None else \"\" ) command = bytes ( f \"\"\" { chdir } env { env_assignments } { args . decode () } \"\"\" , \"utf-8\" , ) return self . process . communicate ( command )","title":"call()"},{"location":"reference/mapyde/runner/","text":"runner \u00b6 File containing functionality for running the various steps in the workflow. dumpconfig \u00b6 dumpconfig ( config : ImmutableConfig ) -> None Dump configuration files used to do stuff, useful for debugging config issues after the fact Source code in mapyde/runner.py def dumpconfig ( config : ImmutableConfig ) -> None : \"\"\" Dump configuration files used to do stuff, useful for debugging config issues after the fact \"\"\" output_path = ( Path ( config [ \"base\" ][ \"path\" ]) . joinpath ( config [ \"base\" ][ \"output\" ]) . joinpath ( \"configs\" ) . resolve () ) output_path . mkdir ( parents = True , exist_ok = True ) now = datetime . now () with open ( utils . output_path ( config ) . joinpath ( f \"configs/config_ { now . year }{ now . month }{ now . day }{ now . hour }{ now . minute }{ now . second } .json\" ), \"w\" , encoding = \"utf-8\" , ) as outfile : json . dump ( config , outfile , ensure_ascii = False , indent = 4 ) mounts \u00b6 mounts ( config : ImmutableConfig ) -> list [ tuple [ PathOrStr , PathOrStr ]] define mount points for all containers Source code in mapyde/runner.py def mounts ( config : ImmutableConfig ) -> list [ tuple [ PathOrStr , PathOrStr ]]: \"\"\" define mount points for all containers \"\"\" return [ ( str ( Path ( config [ \"base\" ][ \"cards_path\" ]) . resolve ()), \"/cards\" ), ( str ( Path ( config [ \"base\" ][ \"scripts_path\" ]) . resolve ()), \"/scripts\" ), ( str ( Path ( config [ \"base\" ][ \"likelihoods_path\" ]) . resolve ()), \"/likelihoods\" ), ( str ( utils . output_path ( config )), \"/data\" ), ] run_ana \u00b6 run_ana ( config : ImmutableConfig ) -> tuple [ bytes , bytes ] Run analysis. Source code in mapyde/runner.py def run_ana ( config : ImmutableConfig ) -> tuple [ bytes , bytes ]: \"\"\" Run analysis. \"\"\" xsec = 1000.0 if config [ \"analysis\" ][ \"XSoverride\" ] > 0 : xsec = config [ \"analysis\" ][ \"XSoverride\" ] else : if ( \"run_without_decays\" in config [ \"madgraph\" ] and config [ \"madgraph\" ][ \"run_without_decays\" ] ): # modify config to access XS from run without decays origcard = config [ \"madgraph\" ][ \"proc\" ][ \"card\" ] origout = config [ \"base\" ][ \"output\" ] config [ \"madgraph\" ][ \"proc\" ][ \"card\" ] = ( config [ \"madgraph\" ][ \"proc\" ][ \"card\" ] + \"_nodecays\" ) config [ \"base\" ][ \"output\" ] = config [ \"base\" ][ \"output\" ] + \"_nodecays\" with utils . output_path ( config ) . joinpath ( config [ \"base\" ][ \"logs\" ], \"docker_mgpy.log\" ) . open ( encoding = \"utf-8\" ) as fpointer : for line in fpointer . readlines (): # TODO: can we flip this logic around to be better? # refactor into a parse_xsec utility or something? if \"Cross-section :\" in line : xsec = float ( line . split ()[ 2 ]) # take the last instance # change config options back config [ \"madgraph\" ][ \"proc\" ][ \"card\" ] = origcard config [ \"base\" ][ \"output\" ] = origout # if we're doing MLM matching and not trusting the final XS output by Pythia, then # fix the XS from before decays to account for matching efficiency if config [ \"madgraph\" ][ \"run\" ][ \"options\" ][ \"xqcut\" ] > 0 : with utils . output_path ( config ) . joinpath ( config [ \"base\" ][ \"logs\" ], \"docker_mgpy.log\" ) . open ( encoding = \"utf-8\" ) as fpointer : for line in fpointer . readlines (): if \"Nb of events after merging\" in line : xsec *= ( float ( line . split ()[ 6 ]) / config [ \"madgraph\" ][ \"nevents\" ] ) # take the last instance elif ( config [ \"madspin\" ][ \"skip\" ] is False and \"branchingratio\" in config [ \"analysis\" ] and config [ \"analysis\" ][ \"branchingratio\" ] > 0 ): # we've run madspin AND set a non-zero BR in the configuration, so we're going # to take the cross section from before madspin runs. with utils . output_path ( config ) . joinpath ( config [ \"base\" ][ \"logs\" ], \"docker_mgpy.log\" ) . open ( encoding = \"utf-8\" ) as fpointer : for line in fpointer . readlines (): # TODO: can we flip this logic around to be better? # refactor into a parse_xsec utility or something? if \"Cross-section :\" in line : xsec = float ( line . split ()[ 2 ]) # take the first instance break # if we're doing MLM matching and not trusting the final XS output by Pythia, then # fix the XS from before decays to account for matching efficiency if config [ \"madgraph\" ][ \"run\" ][ \"options\" ][ \"xqcut\" ] > 0 : with utils . output_path ( config ) . joinpath ( config [ \"base\" ][ \"logs\" ], \"docker_mgpy.log\" ) . open ( encoding = \"utf-8\" ) as fpointer : for line in fpointer . readlines (): if \"Nb of events after merging\" in line : xsec *= ( float ( line . split ()[ 6 ]) / config [ \"madgraph\" ][ \"nevents\" ] ) # take the last instance else : with utils . output_path ( config ) . joinpath ( config [ \"base\" ][ \"logs\" ], \"docker_mgpy.log\" ) . open ( encoding = \"utf-8\" ) as fpointer : for line in fpointer . readlines (): # TODO: can we flip this logic around to be better? # refactor into a parse_xsec utility or something? if config [ \"madgraph\" ][ \"run\" ][ \"options\" ][ \"xqcut\" ] > 0 : if \"Matched cross-section :\" in line : xsec = float ( line . split ()[ 3 ]) # take the last instance else : if \"Cross-section :\" in line : xsec = float ( line . split ()[ 2 ]) # take the last instance if \"branchingratio\" in config [ \"analysis\" ]: xsec *= config [ \"analysis\" ][ \"branchingratio\" ] if config [ \"analysis\" ][ \"kfactor\" ] > 0 : xsec *= config [ \"analysis\" ][ \"kfactor\" ] image = f \"ghcr.io/scipp-atlas/mario-mapyde/ { config [ 'delphes' ][ 'version' ] } \" command = bytes ( f \"\"\"mkdir -p { Path ( config [ 'analysis' ][ 'output' ]) . parent } && \\ /scripts/ { config [ 'analysis' ][ 'script' ] } --input { Path ( '/data' ) . joinpath ( config [ 'delphes' ][ 'output' ]) } \\ --output { config [ 'analysis' ][ 'output' ] } \\ --lumi { config [ 'analysis' ][ 'lumi' ] } \\ --XS { xsec } && \\ rsync -rav . /data/\"\"\" , \"utf-8\" , ) with Container ( image = image , name = f \" { config [ 'base' ][ 'output' ] } __hists\" , engine = config [ \"base\" ] . get ( \"engine\" , \"docker\" ), mounts = mounts ( config ), stdout = sys . stdout , output_path = utils . output_path ( config ), logs_path = config [ \"base\" ][ \"logs\" ], ) as container : stdout , stderr = container . call ( command ) return stdout , stderr run_delphes \u00b6 run_delphes ( config : ImmutableConfig ) -> tuple [ bytes , bytes ] Run delphes. Source code in mapyde/runner.py def run_delphes ( config : ImmutableConfig ) -> tuple [ bytes , bytes ]: \"\"\" Run delphes. \"\"\" # ./test/wrapper_delphes.py config_file image = f \"ghcr.io/scipp-atlas/mario-mapyde/ { config [ 'delphes' ][ 'version' ] } \" command = bytes ( f \"\"\"pwd && ls -lavh && ls -lavh /data && \\ find /data/madgraph -name \"*hepmc.gz\" && \\ cp $(find /data/madgraph -name \"*hepmc.gz\") hepmc.gz && \\ gunzip -f hepmc.gz && \\ cp /cards/delphes/ { config [ 'delphes' ][ 'card' ] } . && \\ /bin/ls -ltrh --color && \\ mkdir -p { Path ( config [ 'delphes' ][ 'output' ]) . parent } && \\ set -x && \\ /usr/local/share/delphes/delphes/DelphesHepMC2 { config [ 'delphes' ][ 'card' ] } { Path ( config [ 'delphes' ][ 'output' ]) } hepmc && \\ set +x && \\ rsync -rav --exclude hepmc . /data/\"\"\" , \"utf-8\" , ) with Container ( image = image , name = f \" { config [ 'base' ][ 'output' ] } __delphes\" , engine = config [ \"base\" ] . get ( \"engine\" , \"docker\" ), mounts = mounts ( config ), stdout = sys . stdout , output_path = utils . output_path ( config ), logs_path = config [ \"base\" ][ \"logs\" ], ) as container : stdout , stderr = container . call ( command ) return stdout , stderr run_madgraph \u00b6 run_madgraph ( config : ImmutableConfig ) -> tuple [ bytes , bytes ] Run madgraph. Source code in mapyde/runner.py def run_madgraph ( config : ImmutableConfig ) -> tuple [ bytes , bytes ]: \"\"\" Run madgraph. \"\"\" # in some cases we'll need to run MG once to get a XS, e.g. without decays, and then run again with the \"real\" proc card. if ( \"run_without_decays\" in config [ \"madgraph\" ] and config [ \"madgraph\" ][ \"run_without_decays\" ] ): # modify config to run without decays and store in a separate area origcard = config [ \"madgraph\" ][ \"proc\" ][ \"card\" ] origout = config [ \"base\" ][ \"output\" ] origpythia = config [ \"pythia\" ][ \"skip\" ] config [ \"madgraph\" ][ \"proc\" ][ \"card\" ] = ( config [ \"madgraph\" ][ \"proc\" ][ \"card\" ] + \"_nodecays\" ) config [ \"base\" ][ \"output\" ] = config [ \"base\" ][ \"output\" ] + \"_nodecays\" config [ \"pythia\" ][ \"skip\" ] = True madgraph . generate_mg5config ( config ) image = f \"ghcr.io/scipp-atlas/mario-mapyde/ { config [ 'madgraph' ][ 'version' ] } \" command = bytes ( f \"mg5_aMC /data/ { config [ 'madgraph' ][ 'generator' ][ 'output' ] } && rsync -a PROC_madgraph /data/madgraph \\n \" , \"utf-8\" , ) with Container ( image = image , name = f \" { config [ 'base' ][ 'output' ] } __mgpy\" , engine = config [ \"base\" ] . get ( \"engine\" , \"docker\" ), mounts = mounts ( config ), stdout = sys . stdout , output_path = utils . output_path ( config ), logs_path = config [ \"base\" ][ \"logs\" ], ) as container : stdout , stderr = container . call ( command ) # change config options back config [ \"madgraph\" ][ \"proc\" ][ \"card\" ] = origcard config [ \"base\" ][ \"output\" ] = origout config [ \"pythia\" ][ \"skip\" ] = origpythia madgraph . generate_mg5config ( config ) image = f \"ghcr.io/scipp-atlas/mario-mapyde/ { config [ 'madgraph' ][ 'version' ] } \" command = bytes ( f \"mg5_aMC /data/ { config [ 'madgraph' ][ 'generator' ][ 'output' ] } && rsync -a PROC_madgraph /data/madgraph \\n \" , \"utf-8\" , ) if config [ \"madgraph\" ] . get ( \"keep_output\" , False ): command = bytes ( f \"mg5_aMC /data/ { config [ 'madgraph' ][ 'generator' ][ 'output' ] } && \\ mkdir -p /data/madgraph && \\ rsync -a PROC_madgraph/Events/run_01/unweighted_events.lhe.gz /data/madgraph/ && \\ rsync -a PROC_madgraph/Events/run_01/tag_1_pythia8_events.hepmc.gz /data/madgraph/ \\n \" , \"utf-8\" , ) with Container ( image = image , name = f \" { config [ 'base' ][ 'output' ] } __mgpy\" , engine = config [ \"base\" ] . get ( \"engine\" , \"docker\" ), mounts = mounts ( config ), stdout = sys . stdout , output_path = utils . output_path ( config ), logs_path = config [ \"base\" ][ \"logs\" ], ) as container : stdout , stderr = container . call ( command ) return stdout , stderr run_pyhf \u00b6 run_pyhf ( config : ImmutableConfig ) -> tuple [ bytes , bytes ] Run statistical inference via pyhf. Source code in mapyde/runner.py def run_pyhf ( config : ImmutableConfig ) -> tuple [ bytes , bytes ]: \"\"\" Run statistical inference via pyhf. \"\"\" assert config image = f \"ghcr.io/scipp-atlas/mario-mapyde/ { config [ 'pyhf' ][ 'image' ] } \" command = bytes ( f \"\"\"python3.8 /scripts/muscan.py -b /likelihoods/ { config [ 'pyhf' ][ 'likelihood' ] } -s { config [ 'sa2json' ][ 'output' ] } -n { config [ 'base' ][ 'output' ] } { config [ 'pyhf' ][ 'gpu-options' ] } { config [ 'pyhf' ][ 'other-options' ] } \"\"\" , \"utf-8\" , ) dumpconfig ( config ) addl_opts = None if \"-c\" not in config [ \"pyhf\" ][ \"gpu-options\" ]: addl_opts = [ \"--gpus\" , \"all\" ] with Container ( image = image , name = f \" { config [ 'base' ][ 'output' ] } __muscan\" , engine = config [ \"base\" ] . get ( \"engine\" , \"docker\" ), mounts = mounts ( config ), stdout = sys . stdout , output_path = utils . output_path ( config ), logs_path = config [ \"base\" ][ \"logs\" ], cwd = \"/data\" , additional_options = addl_opts , ) as container : stdout , stderr = container . call ( command ) return stdout , stderr run_root2hdf5 \u00b6 run_root2hdf5 ( config : ImmutableConfig ) -> tuple [ bytes , bytes ] Transform ROOT file to hdf5 format Source code in mapyde/runner.py def run_root2hdf5 ( config : ImmutableConfig ) -> tuple [ bytes , bytes ]: \"\"\" Transform ROOT file to hdf5 format \"\"\" assert config image = \"ghcr.io/scipp-atlas/mario-mapyde/pyplotting:latest\" command = bytes ( f \"\"\"python3 /scripts/root2hdf5.py { config [ 'root2hdf5' ][ 'input' ] } : { config [ 'root2hdf5' ][ 'treename' ] } \"\"\" , \"utf-8\" , ) with Container ( image = image , name = f \" { config [ 'base' ][ 'output' ] } __root2hdf5\" , engine = config [ \"base\" ] . get ( \"engine\" , \"docker\" ), mounts = mounts ( config ), stdout = sys . stdout , output_path = utils . output_path ( config ), logs_path = config [ \"base\" ][ \"logs\" ], cwd = \"/data\" , ) as container : stdout , stderr = container . call ( command ) return stdout , stderr run_sa2json \u00b6 run_sa2json ( config : ImmutableConfig ) -> tuple [ bytes , bytes ] Convert SA ROOT file to HiFa JSON. Source code in mapyde/runner.py def run_sa2json ( config : ImmutableConfig ) -> tuple [ bytes , bytes ]: \"\"\" Convert SA ROOT file to HiFa JSON. \"\"\" assert config inputstr = \"\" for i in config [ \"sa2json\" ][ \"inputs\" ] . split (): inputstr += f \" -i { i } \" scalefactorstring = \"\" if \"hepmc\" in config [ \"simpleanalysis\" ][ \"input\" ]: # scale weights up by kfactor*br and down by number of generated events scalefactor = config [ \"analysis\" ][ \"kfactor\" ] / config [ \"madgraph\" ][ \"nevents\" ] scalefactorstring = f \"--scale { scalefactor } \" image = f \"ghcr.io/scipp-atlas/mario-mapyde/ { config [ 'sa2json' ][ 'image' ] } \" command = bytes ( f \"\"\"python /scripts/SAtoJSON.py { inputstr } -o { config [ 'sa2json' ][ 'output' ] } -n { config [ 'base' ][ 'output' ] } -b /likelihoods/ { config [ 'pyhf' ][ 'likelihood' ] } -l { config [ 'analysis' ][ 'lumi' ] } { config [ 'sa2json' ][ 'options' ] } { scalefactorstring } \"\"\" , \"utf-8\" , ) with Container ( image = image , name = f \" { config [ 'base' ][ 'output' ] } __SA2json\" , engine = config [ \"base\" ] . get ( \"engine\" , \"docker\" ), mounts = mounts ( config ), stdout = sys . stdout , output_path = utils . output_path ( config ), logs_path = config [ \"base\" ][ \"logs\" ], cwd = \"/data\" , ) as container : stdout , stderr = container . call ( command ) return stdout , stderr run_sherpa \u00b6 run_sherpa ( config : ImmutableConfig ) -> tuple [ bytes , bytes ] Run sherpa. Source code in mapyde/runner.py def run_sherpa ( config : ImmutableConfig ) -> tuple [ bytes , bytes ]: \"\"\" Run sherpa. \"\"\" output_path = ( Path ( config [ \"base\" ][ \"path\" ]) . joinpath ( config [ \"base\" ][ \"output\" ]) . resolve () ) output_path . mkdir ( parents = True , exist_ok = True ) image = \"sherpamc/sherpa:2.2.7\" command = bytes ( f \"\"\"/bin/bash -c \"mkdir sherpa && \\ cd sherpa && \\ cp -p /cards/sherpa/ { config [ 'sherpa' ][ 'proc' ] } . && \\ ls -ltrh && \\ cat { config [ 'sherpa' ][ 'proc' ] } && \\ mpirun -n { config [ 'sherpa' ][ 'cores' ] } Sherpa -f { config [ 'sherpa' ][ 'proc' ] } -e { config [ 'sherpa' ][ 'nevents' ] } && \\ mv sherpa.hepmc.hepmc2g sherpa.hepmc.gz && \\ cd ../ && \\ cp -a sherpa/ /data/\" \"\"\" , \"utf-8\" , ) with Container ( image = image , name = f \" { config [ 'base' ][ 'output' ] } __sherpa\" , engine = config [ \"base\" ] . get ( \"engine\" , \"docker\" ), mounts = mounts ( config ), stdout = sys . stdout , output_path = utils . output_path ( config ), logs_path = config [ \"base\" ][ \"logs\" ], ) as container : stdout , stderr = container . call ( command ) return stdout , stderr run_simpleanalysis \u00b6 run_simpleanalysis ( config : ImmutableConfig ) -> tuple [ bytes , bytes ] Run SimpleAnalysis. Source code in mapyde/runner.py def run_simpleanalysis ( config : ImmutableConfig ) -> tuple [ bytes , bytes ]: \"\"\" Run SimpleAnalysis. \"\"\" image = \"gitlab-registry.cern.ch/atlas-sa/simple-analysis:master\" command = bytes ( f \"\"\"mkdir -p tmp_SA && cd tmp_SA && \\ /opt/SimpleAnalysis/ci/entrypoint.sh simpleAnalysis -a { config [ 'simpleanalysis' ][ 'name' ] } ../ { config [ 'analysis' ][ 'output' ] } -n && \\ mv { config [ 'simpleanalysis' ][ 'name' ] } .root ../ { config [ 'simpleanalysis' ][ 'name' ] }{ config [ 'simpleanalysis' ][ 'outputtag' ] } .root && \\ mv { config [ 'simpleanalysis' ][ 'name' ] } .txt ../ { config [ 'simpleanalysis' ][ 'name' ] }{ config [ 'simpleanalysis' ][ 'outputtag' ] } .txt && \\ cd ../ && rm -rf tmp_SA\"\"\" , \"utf-8\" , ) if ( \"input\" in config [ \"simpleanalysis\" ] and \"hepmc\" in config [ \"simpleanalysis\" ][ \"input\" ] ): command = bytes ( f \"\"\"mkdir -p tmp_SA && cd tmp_SA && \\ find /data -name \"*hepmc.gz\" && \\ cp $(find /data/madgraph -name \"*hepmc.gz\") hepmc.gz && \\ gunzip -f hepmc.gz && \\ /opt/SimpleAnalysis/ci/entrypoint.sh simpleAnalysis -a { config [ 'simpleanalysis' ][ 'name' ] } { config [ 'simpleanalysis' ][ 'input' ] } -n && \\ mv { config [ 'simpleanalysis' ][ 'name' ] } .root ../ { config [ 'simpleanalysis' ][ 'name' ] }{ config [ 'simpleanalysis' ][ 'outputtag' ] } .root && \\ mv { config [ 'simpleanalysis' ][ 'name' ] } .txt ../ { config [ 'simpleanalysis' ][ 'name' ] }{ config [ 'simpleanalysis' ][ 'outputtag' ] } .txt && \\ rm hepmc && \\ cd ../ && rm -rf tmp_SA\"\"\" , \"utf-8\" , ) with Container ( image = image , name = f \" { config [ 'base' ][ 'output' ] } __simpleanalysis\" , engine = config [ \"base\" ] . get ( \"engine\" , \"docker\" ), mounts = mounts ( config ), stdout = sys . stdout , cwd = \"/data\" , output_path = utils . output_path ( config ), logs_path = config [ \"base\" ][ \"logs\" ], ) as container : stdout , stderr = container . call ( command ) return stdout , stderr","title":"runner"},{"location":"reference/mapyde/runner/#mapyde.runner","text":"File containing functionality for running the various steps in the workflow.","title":"runner"},{"location":"reference/mapyde/runner/#mapyde.runner.dumpconfig","text":"dumpconfig ( config : ImmutableConfig ) -> None Dump configuration files used to do stuff, useful for debugging config issues after the fact Source code in mapyde/runner.py def dumpconfig ( config : ImmutableConfig ) -> None : \"\"\" Dump configuration files used to do stuff, useful for debugging config issues after the fact \"\"\" output_path = ( Path ( config [ \"base\" ][ \"path\" ]) . joinpath ( config [ \"base\" ][ \"output\" ]) . joinpath ( \"configs\" ) . resolve () ) output_path . mkdir ( parents = True , exist_ok = True ) now = datetime . now () with open ( utils . output_path ( config ) . joinpath ( f \"configs/config_ { now . year }{ now . month }{ now . day }{ now . hour }{ now . minute }{ now . second } .json\" ), \"w\" , encoding = \"utf-8\" , ) as outfile : json . dump ( config , outfile , ensure_ascii = False , indent = 4 )","title":"dumpconfig()"},{"location":"reference/mapyde/runner/#mapyde.runner.mounts","text":"mounts ( config : ImmutableConfig ) -> list [ tuple [ PathOrStr , PathOrStr ]] define mount points for all containers Source code in mapyde/runner.py def mounts ( config : ImmutableConfig ) -> list [ tuple [ PathOrStr , PathOrStr ]]: \"\"\" define mount points for all containers \"\"\" return [ ( str ( Path ( config [ \"base\" ][ \"cards_path\" ]) . resolve ()), \"/cards\" ), ( str ( Path ( config [ \"base\" ][ \"scripts_path\" ]) . resolve ()), \"/scripts\" ), ( str ( Path ( config [ \"base\" ][ \"likelihoods_path\" ]) . resolve ()), \"/likelihoods\" ), ( str ( utils . output_path ( config )), \"/data\" ), ]","title":"mounts()"},{"location":"reference/mapyde/runner/#mapyde.runner.run_ana","text":"run_ana ( config : ImmutableConfig ) -> tuple [ bytes , bytes ] Run analysis. Source code in mapyde/runner.py def run_ana ( config : ImmutableConfig ) -> tuple [ bytes , bytes ]: \"\"\" Run analysis. \"\"\" xsec = 1000.0 if config [ \"analysis\" ][ \"XSoverride\" ] > 0 : xsec = config [ \"analysis\" ][ \"XSoverride\" ] else : if ( \"run_without_decays\" in config [ \"madgraph\" ] and config [ \"madgraph\" ][ \"run_without_decays\" ] ): # modify config to access XS from run without decays origcard = config [ \"madgraph\" ][ \"proc\" ][ \"card\" ] origout = config [ \"base\" ][ \"output\" ] config [ \"madgraph\" ][ \"proc\" ][ \"card\" ] = ( config [ \"madgraph\" ][ \"proc\" ][ \"card\" ] + \"_nodecays\" ) config [ \"base\" ][ \"output\" ] = config [ \"base\" ][ \"output\" ] + \"_nodecays\" with utils . output_path ( config ) . joinpath ( config [ \"base\" ][ \"logs\" ], \"docker_mgpy.log\" ) . open ( encoding = \"utf-8\" ) as fpointer : for line in fpointer . readlines (): # TODO: can we flip this logic around to be better? # refactor into a parse_xsec utility or something? if \"Cross-section :\" in line : xsec = float ( line . split ()[ 2 ]) # take the last instance # change config options back config [ \"madgraph\" ][ \"proc\" ][ \"card\" ] = origcard config [ \"base\" ][ \"output\" ] = origout # if we're doing MLM matching and not trusting the final XS output by Pythia, then # fix the XS from before decays to account for matching efficiency if config [ \"madgraph\" ][ \"run\" ][ \"options\" ][ \"xqcut\" ] > 0 : with utils . output_path ( config ) . joinpath ( config [ \"base\" ][ \"logs\" ], \"docker_mgpy.log\" ) . open ( encoding = \"utf-8\" ) as fpointer : for line in fpointer . readlines (): if \"Nb of events after merging\" in line : xsec *= ( float ( line . split ()[ 6 ]) / config [ \"madgraph\" ][ \"nevents\" ] ) # take the last instance elif ( config [ \"madspin\" ][ \"skip\" ] is False and \"branchingratio\" in config [ \"analysis\" ] and config [ \"analysis\" ][ \"branchingratio\" ] > 0 ): # we've run madspin AND set a non-zero BR in the configuration, so we're going # to take the cross section from before madspin runs. with utils . output_path ( config ) . joinpath ( config [ \"base\" ][ \"logs\" ], \"docker_mgpy.log\" ) . open ( encoding = \"utf-8\" ) as fpointer : for line in fpointer . readlines (): # TODO: can we flip this logic around to be better? # refactor into a parse_xsec utility or something? if \"Cross-section :\" in line : xsec = float ( line . split ()[ 2 ]) # take the first instance break # if we're doing MLM matching and not trusting the final XS output by Pythia, then # fix the XS from before decays to account for matching efficiency if config [ \"madgraph\" ][ \"run\" ][ \"options\" ][ \"xqcut\" ] > 0 : with utils . output_path ( config ) . joinpath ( config [ \"base\" ][ \"logs\" ], \"docker_mgpy.log\" ) . open ( encoding = \"utf-8\" ) as fpointer : for line in fpointer . readlines (): if \"Nb of events after merging\" in line : xsec *= ( float ( line . split ()[ 6 ]) / config [ \"madgraph\" ][ \"nevents\" ] ) # take the last instance else : with utils . output_path ( config ) . joinpath ( config [ \"base\" ][ \"logs\" ], \"docker_mgpy.log\" ) . open ( encoding = \"utf-8\" ) as fpointer : for line in fpointer . readlines (): # TODO: can we flip this logic around to be better? # refactor into a parse_xsec utility or something? if config [ \"madgraph\" ][ \"run\" ][ \"options\" ][ \"xqcut\" ] > 0 : if \"Matched cross-section :\" in line : xsec = float ( line . split ()[ 3 ]) # take the last instance else : if \"Cross-section :\" in line : xsec = float ( line . split ()[ 2 ]) # take the last instance if \"branchingratio\" in config [ \"analysis\" ]: xsec *= config [ \"analysis\" ][ \"branchingratio\" ] if config [ \"analysis\" ][ \"kfactor\" ] > 0 : xsec *= config [ \"analysis\" ][ \"kfactor\" ] image = f \"ghcr.io/scipp-atlas/mario-mapyde/ { config [ 'delphes' ][ 'version' ] } \" command = bytes ( f \"\"\"mkdir -p { Path ( config [ 'analysis' ][ 'output' ]) . parent } && \\ /scripts/ { config [ 'analysis' ][ 'script' ] } --input { Path ( '/data' ) . joinpath ( config [ 'delphes' ][ 'output' ]) } \\ --output { config [ 'analysis' ][ 'output' ] } \\ --lumi { config [ 'analysis' ][ 'lumi' ] } \\ --XS { xsec } && \\ rsync -rav . /data/\"\"\" , \"utf-8\" , ) with Container ( image = image , name = f \" { config [ 'base' ][ 'output' ] } __hists\" , engine = config [ \"base\" ] . get ( \"engine\" , \"docker\" ), mounts = mounts ( config ), stdout = sys . stdout , output_path = utils . output_path ( config ), logs_path = config [ \"base\" ][ \"logs\" ], ) as container : stdout , stderr = container . call ( command ) return stdout , stderr","title":"run_ana()"},{"location":"reference/mapyde/runner/#mapyde.runner.run_delphes","text":"run_delphes ( config : ImmutableConfig ) -> tuple [ bytes , bytes ] Run delphes. Source code in mapyde/runner.py def run_delphes ( config : ImmutableConfig ) -> tuple [ bytes , bytes ]: \"\"\" Run delphes. \"\"\" # ./test/wrapper_delphes.py config_file image = f \"ghcr.io/scipp-atlas/mario-mapyde/ { config [ 'delphes' ][ 'version' ] } \" command = bytes ( f \"\"\"pwd && ls -lavh && ls -lavh /data && \\ find /data/madgraph -name \"*hepmc.gz\" && \\ cp $(find /data/madgraph -name \"*hepmc.gz\") hepmc.gz && \\ gunzip -f hepmc.gz && \\ cp /cards/delphes/ { config [ 'delphes' ][ 'card' ] } . && \\ /bin/ls -ltrh --color && \\ mkdir -p { Path ( config [ 'delphes' ][ 'output' ]) . parent } && \\ set -x && \\ /usr/local/share/delphes/delphes/DelphesHepMC2 { config [ 'delphes' ][ 'card' ] } { Path ( config [ 'delphes' ][ 'output' ]) } hepmc && \\ set +x && \\ rsync -rav --exclude hepmc . /data/\"\"\" , \"utf-8\" , ) with Container ( image = image , name = f \" { config [ 'base' ][ 'output' ] } __delphes\" , engine = config [ \"base\" ] . get ( \"engine\" , \"docker\" ), mounts = mounts ( config ), stdout = sys . stdout , output_path = utils . output_path ( config ), logs_path = config [ \"base\" ][ \"logs\" ], ) as container : stdout , stderr = container . call ( command ) return stdout , stderr","title":"run_delphes()"},{"location":"reference/mapyde/runner/#mapyde.runner.run_madgraph","text":"run_madgraph ( config : ImmutableConfig ) -> tuple [ bytes , bytes ] Run madgraph. Source code in mapyde/runner.py def run_madgraph ( config : ImmutableConfig ) -> tuple [ bytes , bytes ]: \"\"\" Run madgraph. \"\"\" # in some cases we'll need to run MG once to get a XS, e.g. without decays, and then run again with the \"real\" proc card. if ( \"run_without_decays\" in config [ \"madgraph\" ] and config [ \"madgraph\" ][ \"run_without_decays\" ] ): # modify config to run without decays and store in a separate area origcard = config [ \"madgraph\" ][ \"proc\" ][ \"card\" ] origout = config [ \"base\" ][ \"output\" ] origpythia = config [ \"pythia\" ][ \"skip\" ] config [ \"madgraph\" ][ \"proc\" ][ \"card\" ] = ( config [ \"madgraph\" ][ \"proc\" ][ \"card\" ] + \"_nodecays\" ) config [ \"base\" ][ \"output\" ] = config [ \"base\" ][ \"output\" ] + \"_nodecays\" config [ \"pythia\" ][ \"skip\" ] = True madgraph . generate_mg5config ( config ) image = f \"ghcr.io/scipp-atlas/mario-mapyde/ { config [ 'madgraph' ][ 'version' ] } \" command = bytes ( f \"mg5_aMC /data/ { config [ 'madgraph' ][ 'generator' ][ 'output' ] } && rsync -a PROC_madgraph /data/madgraph \\n \" , \"utf-8\" , ) with Container ( image = image , name = f \" { config [ 'base' ][ 'output' ] } __mgpy\" , engine = config [ \"base\" ] . get ( \"engine\" , \"docker\" ), mounts = mounts ( config ), stdout = sys . stdout , output_path = utils . output_path ( config ), logs_path = config [ \"base\" ][ \"logs\" ], ) as container : stdout , stderr = container . call ( command ) # change config options back config [ \"madgraph\" ][ \"proc\" ][ \"card\" ] = origcard config [ \"base\" ][ \"output\" ] = origout config [ \"pythia\" ][ \"skip\" ] = origpythia madgraph . generate_mg5config ( config ) image = f \"ghcr.io/scipp-atlas/mario-mapyde/ { config [ 'madgraph' ][ 'version' ] } \" command = bytes ( f \"mg5_aMC /data/ { config [ 'madgraph' ][ 'generator' ][ 'output' ] } && rsync -a PROC_madgraph /data/madgraph \\n \" , \"utf-8\" , ) if config [ \"madgraph\" ] . get ( \"keep_output\" , False ): command = bytes ( f \"mg5_aMC /data/ { config [ 'madgraph' ][ 'generator' ][ 'output' ] } && \\ mkdir -p /data/madgraph && \\ rsync -a PROC_madgraph/Events/run_01/unweighted_events.lhe.gz /data/madgraph/ && \\ rsync -a PROC_madgraph/Events/run_01/tag_1_pythia8_events.hepmc.gz /data/madgraph/ \\n \" , \"utf-8\" , ) with Container ( image = image , name = f \" { config [ 'base' ][ 'output' ] } __mgpy\" , engine = config [ \"base\" ] . get ( \"engine\" , \"docker\" ), mounts = mounts ( config ), stdout = sys . stdout , output_path = utils . output_path ( config ), logs_path = config [ \"base\" ][ \"logs\" ], ) as container : stdout , stderr = container . call ( command ) return stdout , stderr","title":"run_madgraph()"},{"location":"reference/mapyde/runner/#mapyde.runner.run_pyhf","text":"run_pyhf ( config : ImmutableConfig ) -> tuple [ bytes , bytes ] Run statistical inference via pyhf. Source code in mapyde/runner.py def run_pyhf ( config : ImmutableConfig ) -> tuple [ bytes , bytes ]: \"\"\" Run statistical inference via pyhf. \"\"\" assert config image = f \"ghcr.io/scipp-atlas/mario-mapyde/ { config [ 'pyhf' ][ 'image' ] } \" command = bytes ( f \"\"\"python3.8 /scripts/muscan.py -b /likelihoods/ { config [ 'pyhf' ][ 'likelihood' ] } -s { config [ 'sa2json' ][ 'output' ] } -n { config [ 'base' ][ 'output' ] } { config [ 'pyhf' ][ 'gpu-options' ] } { config [ 'pyhf' ][ 'other-options' ] } \"\"\" , \"utf-8\" , ) dumpconfig ( config ) addl_opts = None if \"-c\" not in config [ \"pyhf\" ][ \"gpu-options\" ]: addl_opts = [ \"--gpus\" , \"all\" ] with Container ( image = image , name = f \" { config [ 'base' ][ 'output' ] } __muscan\" , engine = config [ \"base\" ] . get ( \"engine\" , \"docker\" ), mounts = mounts ( config ), stdout = sys . stdout , output_path = utils . output_path ( config ), logs_path = config [ \"base\" ][ \"logs\" ], cwd = \"/data\" , additional_options = addl_opts , ) as container : stdout , stderr = container . call ( command ) return stdout , stderr","title":"run_pyhf()"},{"location":"reference/mapyde/runner/#mapyde.runner.run_root2hdf5","text":"run_root2hdf5 ( config : ImmutableConfig ) -> tuple [ bytes , bytes ] Transform ROOT file to hdf5 format Source code in mapyde/runner.py def run_root2hdf5 ( config : ImmutableConfig ) -> tuple [ bytes , bytes ]: \"\"\" Transform ROOT file to hdf5 format \"\"\" assert config image = \"ghcr.io/scipp-atlas/mario-mapyde/pyplotting:latest\" command = bytes ( f \"\"\"python3 /scripts/root2hdf5.py { config [ 'root2hdf5' ][ 'input' ] } : { config [ 'root2hdf5' ][ 'treename' ] } \"\"\" , \"utf-8\" , ) with Container ( image = image , name = f \" { config [ 'base' ][ 'output' ] } __root2hdf5\" , engine = config [ \"base\" ] . get ( \"engine\" , \"docker\" ), mounts = mounts ( config ), stdout = sys . stdout , output_path = utils . output_path ( config ), logs_path = config [ \"base\" ][ \"logs\" ], cwd = \"/data\" , ) as container : stdout , stderr = container . call ( command ) return stdout , stderr","title":"run_root2hdf5()"},{"location":"reference/mapyde/runner/#mapyde.runner.run_sa2json","text":"run_sa2json ( config : ImmutableConfig ) -> tuple [ bytes , bytes ] Convert SA ROOT file to HiFa JSON. Source code in mapyde/runner.py def run_sa2json ( config : ImmutableConfig ) -> tuple [ bytes , bytes ]: \"\"\" Convert SA ROOT file to HiFa JSON. \"\"\" assert config inputstr = \"\" for i in config [ \"sa2json\" ][ \"inputs\" ] . split (): inputstr += f \" -i { i } \" scalefactorstring = \"\" if \"hepmc\" in config [ \"simpleanalysis\" ][ \"input\" ]: # scale weights up by kfactor*br and down by number of generated events scalefactor = config [ \"analysis\" ][ \"kfactor\" ] / config [ \"madgraph\" ][ \"nevents\" ] scalefactorstring = f \"--scale { scalefactor } \" image = f \"ghcr.io/scipp-atlas/mario-mapyde/ { config [ 'sa2json' ][ 'image' ] } \" command = bytes ( f \"\"\"python /scripts/SAtoJSON.py { inputstr } -o { config [ 'sa2json' ][ 'output' ] } -n { config [ 'base' ][ 'output' ] } -b /likelihoods/ { config [ 'pyhf' ][ 'likelihood' ] } -l { config [ 'analysis' ][ 'lumi' ] } { config [ 'sa2json' ][ 'options' ] } { scalefactorstring } \"\"\" , \"utf-8\" , ) with Container ( image = image , name = f \" { config [ 'base' ][ 'output' ] } __SA2json\" , engine = config [ \"base\" ] . get ( \"engine\" , \"docker\" ), mounts = mounts ( config ), stdout = sys . stdout , output_path = utils . output_path ( config ), logs_path = config [ \"base\" ][ \"logs\" ], cwd = \"/data\" , ) as container : stdout , stderr = container . call ( command ) return stdout , stderr","title":"run_sa2json()"},{"location":"reference/mapyde/runner/#mapyde.runner.run_sherpa","text":"run_sherpa ( config : ImmutableConfig ) -> tuple [ bytes , bytes ] Run sherpa. Source code in mapyde/runner.py def run_sherpa ( config : ImmutableConfig ) -> tuple [ bytes , bytes ]: \"\"\" Run sherpa. \"\"\" output_path = ( Path ( config [ \"base\" ][ \"path\" ]) . joinpath ( config [ \"base\" ][ \"output\" ]) . resolve () ) output_path . mkdir ( parents = True , exist_ok = True ) image = \"sherpamc/sherpa:2.2.7\" command = bytes ( f \"\"\"/bin/bash -c \"mkdir sherpa && \\ cd sherpa && \\ cp -p /cards/sherpa/ { config [ 'sherpa' ][ 'proc' ] } . && \\ ls -ltrh && \\ cat { config [ 'sherpa' ][ 'proc' ] } && \\ mpirun -n { config [ 'sherpa' ][ 'cores' ] } Sherpa -f { config [ 'sherpa' ][ 'proc' ] } -e { config [ 'sherpa' ][ 'nevents' ] } && \\ mv sherpa.hepmc.hepmc2g sherpa.hepmc.gz && \\ cd ../ && \\ cp -a sherpa/ /data/\" \"\"\" , \"utf-8\" , ) with Container ( image = image , name = f \" { config [ 'base' ][ 'output' ] } __sherpa\" , engine = config [ \"base\" ] . get ( \"engine\" , \"docker\" ), mounts = mounts ( config ), stdout = sys . stdout , output_path = utils . output_path ( config ), logs_path = config [ \"base\" ][ \"logs\" ], ) as container : stdout , stderr = container . call ( command ) return stdout , stderr","title":"run_sherpa()"},{"location":"reference/mapyde/runner/#mapyde.runner.run_simpleanalysis","text":"run_simpleanalysis ( config : ImmutableConfig ) -> tuple [ bytes , bytes ] Run SimpleAnalysis. Source code in mapyde/runner.py def run_simpleanalysis ( config : ImmutableConfig ) -> tuple [ bytes , bytes ]: \"\"\" Run SimpleAnalysis. \"\"\" image = \"gitlab-registry.cern.ch/atlas-sa/simple-analysis:master\" command = bytes ( f \"\"\"mkdir -p tmp_SA && cd tmp_SA && \\ /opt/SimpleAnalysis/ci/entrypoint.sh simpleAnalysis -a { config [ 'simpleanalysis' ][ 'name' ] } ../ { config [ 'analysis' ][ 'output' ] } -n && \\ mv { config [ 'simpleanalysis' ][ 'name' ] } .root ../ { config [ 'simpleanalysis' ][ 'name' ] }{ config [ 'simpleanalysis' ][ 'outputtag' ] } .root && \\ mv { config [ 'simpleanalysis' ][ 'name' ] } .txt ../ { config [ 'simpleanalysis' ][ 'name' ] }{ config [ 'simpleanalysis' ][ 'outputtag' ] } .txt && \\ cd ../ && rm -rf tmp_SA\"\"\" , \"utf-8\" , ) if ( \"input\" in config [ \"simpleanalysis\" ] and \"hepmc\" in config [ \"simpleanalysis\" ][ \"input\" ] ): command = bytes ( f \"\"\"mkdir -p tmp_SA && cd tmp_SA && \\ find /data -name \"*hepmc.gz\" && \\ cp $(find /data/madgraph -name \"*hepmc.gz\") hepmc.gz && \\ gunzip -f hepmc.gz && \\ /opt/SimpleAnalysis/ci/entrypoint.sh simpleAnalysis -a { config [ 'simpleanalysis' ][ 'name' ] } { config [ 'simpleanalysis' ][ 'input' ] } -n && \\ mv { config [ 'simpleanalysis' ][ 'name' ] } .root ../ { config [ 'simpleanalysis' ][ 'name' ] }{ config [ 'simpleanalysis' ][ 'outputtag' ] } .root && \\ mv { config [ 'simpleanalysis' ][ 'name' ] } .txt ../ { config [ 'simpleanalysis' ][ 'name' ] }{ config [ 'simpleanalysis' ][ 'outputtag' ] } .txt && \\ rm hepmc && \\ cd ../ && rm -rf tmp_SA\"\"\" , \"utf-8\" , ) with Container ( image = image , name = f \" { config [ 'base' ][ 'output' ] } __simpleanalysis\" , engine = config [ \"base\" ] . get ( \"engine\" , \"docker\" ), mounts = mounts ( config ), stdout = sys . stdout , cwd = \"/data\" , output_path = utils . output_path ( config ), logs_path = config [ \"base\" ][ \"logs\" ], ) as container : stdout , stderr = container . call ( command ) return stdout , stderr","title":"run_simpleanalysis()"},{"location":"reference/mapyde/typing/","text":"typing \u00b6 Typehint helpers.","title":"typing"},{"location":"reference/mapyde/typing/#mapyde.typing","text":"Typehint helpers.","title":"typing"},{"location":"reference/mapyde/utils/","text":"utils \u00b6 Utilities for managing configuration. build_config \u00b6 build_config ( user : MutableConfig ) -> T . Any Function to build a configuration from a user-provided toml configuration on top of the base/template one. Source code in mapyde/utils.py def build_config ( user : MutableConfig ) -> T . Any : \"\"\" Function to build a configuration from a user-provided toml configuration on top of the base/template one. \"\"\" template_path = Path ( render_string ( user [ \"base\" ] . get ( \"template\" , \"{{MAPYDE_TEMPLATES}}/defaults.toml\" ) ) ) with resources . as_file ( template_path ) as template : if not template . exists (): raise OSError ( f \" { template_path } does not exist.\" ) defaults = load_config ( template . name , str ( template . parent )) variables = merge ( defaults , user ) config = toml . loads ( render_string ( toml . dumps ( variables ), variables )) return config env_override \u00b6 env_override ( value : T . Any , key : str ) -> T . Any Helper function for jinja2 to override environment variables Source code in mapyde/utils.py def env_override ( value : T . Any , key : str ) -> T . Any : \"\"\" Helper function for jinja2 to override environment variables \"\"\" return os . getenv ( key , value ) load_config \u00b6 load_config ( filename : str , cwd : str = '.' ) -> T . Any Helper function to load a local toml configuration by filename Source code in mapyde/utils.py def load_config ( filename : str , cwd : str = \".\" ) -> T . Any : \"\"\" Helper function to load a local toml configuration by filename \"\"\" env = Environment ( loader = FileSystemLoader ( cwd )) env . filters [ \"env_override\" ] = env_override tpl = env . get_template ( filename ) assert tpl . filename return toml . load ( open ( tpl . filename , encoding = \"utf-8\" )) merge \u00b6 merge ( left : MutableConfig , right : ImmutableConfig , path : T . Optional [ list [ str ]] = None ) -> ImmutableConfig merges right dictionary into left dictionary Source code in mapyde/utils.py def merge ( left : MutableConfig , right : ImmutableConfig , path : T . Optional [ list [ str ]] = None ) -> ImmutableConfig : \"\"\" merges right dictionary into left dictionary \"\"\" if path is None : path = [] for key in right : if key in left : if isinstance ( left [ key ], dict ) and isinstance ( right [ key ], dict ): merge ( left [ key ], right [ key ], path + [ str ( key )]) else : left [ key ] = right [ key ] else : left [ key ] = right [ key ] return left output_path \u00b6 output_path ( config : ImmutableConfig ) -> Path Return the output path from the config. Source code in mapyde/utils.py def output_path ( config : ImmutableConfig ) -> Path : \"\"\" Return the output path from the config. \"\"\" return Path ( config [ \"base\" ][ \"path\" ]) . joinpath ( config [ \"base\" ][ \"output\" ]) . resolve () render_string \u00b6 render_string ( blob : str , variables : T . Optional [ ImmutableConfig ] = None ) -> str Render a string using various variables set by the mapyde package. Source code in mapyde/utils.py def render_string ( blob : str , variables : T . Optional [ ImmutableConfig ] = None ) -> str : \"\"\" Render a string using various variables set by the mapyde package. \"\"\" variables = variables or {} tpl = Template ( blob ) return tpl . render ( PWD = os . getenv ( \"PWD\" ), USER = os . getenv ( \"USER\" ), MAPYDE_DATA = data , MAPYDE_CARDS = cards , MAPYDE_LIKELIHOODS = likelihoods , MAPYDE_SCRIPTS = scripts , MAPYDE_TEMPLATES = templates , ** variables , ) slugify \u00b6 slugify ( value : str , allow_unicode : bool = False ) -> str Taken from https://github.com/django/django/blob/master/django/utils/text.py Convert to ASCII if 'allow_unicode' is False. Convert spaces or repeated dashes to single dashes. Remove characters that aren't alphanumerics, underscores, or hyphens. Convert to lowercase. Also strip leading and trailing whitespace, dashes, and underscores. Source code in mapyde/utils.py def slugify ( value : str , allow_unicode : bool = False ) -> str : \"\"\" Taken from https://github.com/django/django/blob/master/django/utils/text.py Convert to ASCII if 'allow_unicode' is False. Convert spaces or repeated dashes to single dashes. Remove characters that aren't alphanumerics, underscores, or hyphens. Convert to lowercase. Also strip leading and trailing whitespace, dashes, and underscores. \"\"\" value = str ( value ) if allow_unicode : value = unicodedata . normalize ( \"NFKC\" , value ) else : value = ( unicodedata . normalize ( \"NFKD\" , value ) . encode ( \"ascii\" , \"ignore\" ) . decode ( \"ascii\" ) ) value = re . sub ( r \"[^\\w\\s-]\" , \"\" , value . lower ()) return re . sub ( r \"[-\\s]+\" , \"-\" , value ) . strip ( \"-_\" )","title":"utils"},{"location":"reference/mapyde/utils/#mapyde.utils","text":"Utilities for managing configuration.","title":"utils"},{"location":"reference/mapyde/utils/#mapyde.utils.build_config","text":"build_config ( user : MutableConfig ) -> T . Any Function to build a configuration from a user-provided toml configuration on top of the base/template one. Source code in mapyde/utils.py def build_config ( user : MutableConfig ) -> T . Any : \"\"\" Function to build a configuration from a user-provided toml configuration on top of the base/template one. \"\"\" template_path = Path ( render_string ( user [ \"base\" ] . get ( \"template\" , \"{{MAPYDE_TEMPLATES}}/defaults.toml\" ) ) ) with resources . as_file ( template_path ) as template : if not template . exists (): raise OSError ( f \" { template_path } does not exist.\" ) defaults = load_config ( template . name , str ( template . parent )) variables = merge ( defaults , user ) config = toml . loads ( render_string ( toml . dumps ( variables ), variables )) return config","title":"build_config()"},{"location":"reference/mapyde/utils/#mapyde.utils.env_override","text":"env_override ( value : T . Any , key : str ) -> T . Any Helper function for jinja2 to override environment variables Source code in mapyde/utils.py def env_override ( value : T . Any , key : str ) -> T . Any : \"\"\" Helper function for jinja2 to override environment variables \"\"\" return os . getenv ( key , value )","title":"env_override()"},{"location":"reference/mapyde/utils/#mapyde.utils.load_config","text":"load_config ( filename : str , cwd : str = '.' ) -> T . Any Helper function to load a local toml configuration by filename Source code in mapyde/utils.py def load_config ( filename : str , cwd : str = \".\" ) -> T . Any : \"\"\" Helper function to load a local toml configuration by filename \"\"\" env = Environment ( loader = FileSystemLoader ( cwd )) env . filters [ \"env_override\" ] = env_override tpl = env . get_template ( filename ) assert tpl . filename return toml . load ( open ( tpl . filename , encoding = \"utf-8\" ))","title":"load_config()"},{"location":"reference/mapyde/utils/#mapyde.utils.merge","text":"merge ( left : MutableConfig , right : ImmutableConfig , path : T . Optional [ list [ str ]] = None ) -> ImmutableConfig merges right dictionary into left dictionary Source code in mapyde/utils.py def merge ( left : MutableConfig , right : ImmutableConfig , path : T . Optional [ list [ str ]] = None ) -> ImmutableConfig : \"\"\" merges right dictionary into left dictionary \"\"\" if path is None : path = [] for key in right : if key in left : if isinstance ( left [ key ], dict ) and isinstance ( right [ key ], dict ): merge ( left [ key ], right [ key ], path + [ str ( key )]) else : left [ key ] = right [ key ] else : left [ key ] = right [ key ] return left","title":"merge()"},{"location":"reference/mapyde/utils/#mapyde.utils.output_path","text":"output_path ( config : ImmutableConfig ) -> Path Return the output path from the config. Source code in mapyde/utils.py def output_path ( config : ImmutableConfig ) -> Path : \"\"\" Return the output path from the config. \"\"\" return Path ( config [ \"base\" ][ \"path\" ]) . joinpath ( config [ \"base\" ][ \"output\" ]) . resolve ()","title":"output_path()"},{"location":"reference/mapyde/utils/#mapyde.utils.render_string","text":"render_string ( blob : str , variables : T . Optional [ ImmutableConfig ] = None ) -> str Render a string using various variables set by the mapyde package. Source code in mapyde/utils.py def render_string ( blob : str , variables : T . Optional [ ImmutableConfig ] = None ) -> str : \"\"\" Render a string using various variables set by the mapyde package. \"\"\" variables = variables or {} tpl = Template ( blob ) return tpl . render ( PWD = os . getenv ( \"PWD\" ), USER = os . getenv ( \"USER\" ), MAPYDE_DATA = data , MAPYDE_CARDS = cards , MAPYDE_LIKELIHOODS = likelihoods , MAPYDE_SCRIPTS = scripts , MAPYDE_TEMPLATES = templates , ** variables , )","title":"render_string()"},{"location":"reference/mapyde/utils/#mapyde.utils.slugify","text":"slugify ( value : str , allow_unicode : bool = False ) -> str Taken from https://github.com/django/django/blob/master/django/utils/text.py Convert to ASCII if 'allow_unicode' is False. Convert spaces or repeated dashes to single dashes. Remove characters that aren't alphanumerics, underscores, or hyphens. Convert to lowercase. Also strip leading and trailing whitespace, dashes, and underscores. Source code in mapyde/utils.py def slugify ( value : str , allow_unicode : bool = False ) -> str : \"\"\" Taken from https://github.com/django/django/blob/master/django/utils/text.py Convert to ASCII if 'allow_unicode' is False. Convert spaces or repeated dashes to single dashes. Remove characters that aren't alphanumerics, underscores, or hyphens. Convert to lowercase. Also strip leading and trailing whitespace, dashes, and underscores. \"\"\" value = str ( value ) if allow_unicode : value = unicodedata . normalize ( \"NFKC\" , value ) else : value = ( unicodedata . normalize ( \"NFKD\" , value ) . encode ( \"ascii\" , \"ignore\" ) . decode ( \"ascii\" ) ) value = re . sub ( r \"[^\\w\\s-]\" , \"\" , value . lower ()) return re . sub ( r \"[-\\s]+\" , \"-\" , value ) . strip ( \"-_\" )","title":"slugify()"},{"location":"reference/mapyde/backends/","text":"backends \u00b6","title":"backends"},{"location":"reference/mapyde/backends/#mapyde.backends","text":"","title":"backends"},{"location":"reference/mapyde/backends/madgraph/","text":"madgraph \u00b6 Helpers for madgraph generate_mg5config \u00b6 generate_mg5config ( config : ImmutableConfig ) -> None Helper for generating the madgraph configs. Replaces mg5creator.py. Source code in mapyde/backends/madgraph.py def generate_mg5config ( config : ImmutableConfig ) -> None : \"\"\" Helper for generating the madgraph configs. Replaces mg5creator.py. \"\"\" old_versions = [ \"2.4.3\" , \"2.3.3\" ] is_old_version = False if any ( version in config [ \"madgraph\" ][ \"version\" ] for version in old_versions ): is_old_version = True log . warning ( \"Old madgraph version detected: %s \" , config [ \"madgraph\" ][ \"version\" ]) output_path = ( Path ( config [ \"base\" ][ \"path\" ]) . joinpath ( config [ \"base\" ][ \"output\" ]) . resolve () ) output_path . mkdir ( parents = True , exist_ok = True ) # Ensure pythia card exists _pythia_card_path = Path ( config [ \"base\" ][ \"pythia_path\" ]) . joinpath ( config [ \"pythia\" ][ \"card\" ] ) if not _pythia_card_path . exists (): log . error ( \" %s does not exist.\" , _pythia_card_path ) sys . exit ( 1 ) # Controls whether to run Pythia8 or not pythia_config_path = \"\" pythia_onoff = \"OFF\" if not config [ \"pythia\" ][ \"skip\" ]: # Copy the pythia card pythia_card_path = ( Path ( config [ \"base\" ][ \"pythia_path\" ]) . joinpath ( config [ \"pythia\" ][ \"card\" ]) . resolve () ) new_pythia_card_path = output_path . joinpath ( \"pythia_card.dat\" ) # block below replaces a straightforward copy of pythia card to run area with open ( new_pythia_card_path , \"w\" , encoding = \"utf-8\" ) as new_pythia_card : with open ( pythia_card_path , encoding = \"utf-8\" ) as pcard : for line in pcard : # now handle specific pythia options. can be refactored later to be more elegant. # really only turning MPI on/off at the moment if \"partonlevel:mpi\" in line and \"mpi\" in config [ \"pythia\" ]: if config [ \"pythia\" ][ \"mpi\" ] == \"on\" : new_pythia_card . write ( \"partonlevel:mpi = on\" ) elif config [ \"pythia\" ][ \"mpi\" ] == \"off\" : new_pythia_card . write ( \"partonlevel:mpi = off\" ) else : log . error ( \"partonlevel:mpi can only be 'on' or 'off', not %s \" , config [ \"pythia\" ][ \"mpi\" ], ) sys . exit ( 1 ) else : new_pythia_card . write ( line ) if \"additional_opts\" in config [ \"pythia\" ]: new_pythia_card . write ( \" \\n \" ) new_pythia_card . write ( config [ \"pythia\" ][ \"additional_opts\" ]) log . info ( \"Pythia Card: %s \" , new_pythia_card_path ) pythia_onoff = \"Pythia8\" pythia_config_path = f \"/data/ { new_pythia_card_path . name } \" substitution = dict ( ecms = float ( config [ \"madgraph\" ][ \"ecms\" ]) / 2 , nevents = int ( config [ \"madgraph\" ][ \"nevents\" ]), iseed = int ( config [ \"madgraph\" ][ \"seed\" ]), ) masses = config [ \"madgraph\" ] . get ( \"masses\" , {}) if any ( key in masses for key in substitution ): raise ValueError ( \"Particles cannot be named ecms, nevents, or iseed.\" ) substitution . update ( masses ) log . info ( \"The following values will be substituted in where possible:\" ) for key , value in substitution . items (): log . info ( \" $ %s = %s \" , key , value ) # Update the param card param_card_path = ( Path ( config [ \"base\" ][ \"param_path\" ]) . joinpath ( config [ \"madgraph\" ][ \"paramcard\" ]) . resolve () ) new_param_card_path = output_path . joinpath ( param_card_path . name ) log . info ( \"Param Card: %s \" , new_param_card_path ) new_param_card_path . write_text ( Template ( param_card_path . read_text ( encoding = \"utf-8\" ), undefined = StrictUndefined ) . render ( substitution ), encoding = \"utf-8\" , ) # Update the run card run_card_path = ( Path ( config [ \"base\" ][ \"run_path\" ]) . joinpath ( config [ \"madgraph\" ][ \"run\" ][ \"card\" ]) . resolve () ) if is_old_version : log . warning ( \"Changing the run card due to old madgraph version.\" ) run_card_path = run_card_path . parent . joinpath ( \"default_LO_oldformat.dat\" ) new_run_card_path = output_path . joinpath ( run_card_path . name ) log . info ( \"Run Card: %s \" , new_run_card_path ) # -- first do global opts new_run_card_path . write_text ( Template ( run_card_path . read_text ( encoding = \"utf-8\" ), undefined = StrictUndefined ) . render ( substitution ), encoding = \"utf-8\" , ) # -- now specific opts. may want to reverse this order at some point, and do the specific before global. # Note: this will only work with options in the run card that contain a \"!\" in the line, indicating a comment at the end of the line. run_options = { ** config [ \"madgraph\" ][ \"run\" ] . get ( \"options\" , {})} # env = Environment() # parsed_content = env.parse('my text here') # tpl_variables = meta.find_undeclared_variables(parsed) pattern = re . compile ( r \"^\\s*(?P<value>[^\\s]+)\\s*=\\s*(?P<key>[a-z_0-9]+)\\s*\\!.*$\" , re . DOTALL ) with in_place . InPlace ( new_run_card_path ) as fpointer : for line in fpointer : match = pattern . match ( line ) if match : groups = match . groupdict () span = match . span ( \"value\" ) newvalue = str ( run_options . pop ( groups [ \"key\" ], groups [ \"value\" ])) # update the line based on input from the user, default to what is in the file line = line [: span [ 0 ]] + newvalue + line [ span [ 1 ] :] if not newvalue == groups [ \"value\" ]: log . info ( \" replacing value for %s : %s -> %s \" , groups [ \"key\" ], groups [ \"value\" ], newvalue , ) fpointer . write ( line ) unused_keys = list ( run_options . keys ()) if unused_keys : log . error ( \"Unused keys supplied by you: %s \" , unused_keys ) raise KeyError ( unused_keys [ 0 ]) # Copy the proc card proc_card_path = ( Path ( config [ \"base\" ][ \"process_path\" ]) . joinpath ( config [ \"madgraph\" ][ \"proc\" ][ \"card\" ]) . resolve () ) new_proc_card_path = output_path . joinpath ( proc_card_path . name ) log . info ( \"Process Card: %s \" , new_proc_card_path ) shutil . copyfile ( proc_card_path , new_proc_card_path ) # Create the madgraph configuration card mgconfig_card_path = output_path . joinpath ( config [ \"madgraph\" ][ \"generator\" ][ \"output\" ]) log . info ( \"MadGraph Config: %s \" , mgconfig_card_path ) # Figure out the run_mode. 0=single core, 1=cluster, 2=multicore. if config [ \"madgraph\" ][ \"batch\" ]: run_mode = \"set run_mode 0\" # we don't have MadGraph launch cluster jobs for us, we handle that ourselves. elif int ( config [ \"madgraph\" ][ \"cores\" ]) > 0 : run_mode = f \"set run_mode 2 \\n set nb_core { config [ 'madgraph' ][ 'cores' ] } \" else : run_mode = f \"set run_mode 2 \\n set nb_core { multiprocessing . cpu_count () / 2 } \" # figure out if running with madspin or not, and if so, put the card in the right place madspin_onoff = \"OFF\" madspin_config_path = \"\" if not config [ \"madspin\" ][ \"skip\" ]: # Copy the madspin card madspin_card_path = ( Path ( config [ \"base\" ][ \"madspin_path\" ]) . joinpath ( config [ \"madspin\" ][ \"card\" ]) . resolve () ) new_madspin_card_path = output_path . joinpath ( \"madspin_card.dat\" ) # block below replaces a straightforward copy of madspin card to run area, # but allows us to modify the card according to config options with open ( new_madspin_card_path , \"w\" , encoding = \"utf-8\" ) as new_madspin_card : with open ( madspin_card_path , encoding = \"utf-8\" ) as pcard : for line in pcard : # now handle specific madspin options. can be refactored later # to be more elegant. really only changing the spinmode at the moment if \"set spinmode\" in line and \"spinmode\" in config [ \"madspin\" ]: new_madspin_card . write ( f \"set spinmode { config [ 'madspin' ][ 'spinmode' ] } \\n \" ) else : new_madspin_card . write ( line ) log . info ( \"MadSpin Card: %s \" , new_madspin_card_path ) madspin_onoff = \"ON\" madspin_config_path = f \"/data/ { new_madspin_card_path . name } \" mg5config = f \"\"\" { run_mode } launch PROC_madgraph madspin= { madspin_onoff } shower= { pythia_onoff } reweight=OFF { madspin_config_path } /data/ { new_param_card_path . name } /data/ { new_run_card_path . name } { pythia_config_path } set iseed { config [ 'madgraph' ][ 'seed' ] } done \"\"\" if is_old_version : mg5config = f \"\"\" { run_mode } launch PROC_madgraph madspin= { madspin_onoff } reweight=OFF { madspin_config_path } /data/ { new_param_card_path . name } /data/ { new_run_card_path . name } done \"\"\" with mgconfig_card_path . open ( mode = \"w\" , encoding = \"utf-8\" ) as fpointer : for proc_line in new_proc_card_path . open ( encoding = \"utf-8\" ): if not proc_line . strip (): continue if proc_line . startswith ( \"output\" ): proc_line = \"output PROC_madgraph \\n \" fpointer . write ( proc_line ) fpointer . write ( mg5config )","title":"madgraph"},{"location":"reference/mapyde/backends/madgraph/#mapyde.backends.madgraph","text":"Helpers for madgraph","title":"madgraph"},{"location":"reference/mapyde/backends/madgraph/#mapyde.backends.madgraph.generate_mg5config","text":"generate_mg5config ( config : ImmutableConfig ) -> None Helper for generating the madgraph configs. Replaces mg5creator.py. Source code in mapyde/backends/madgraph.py def generate_mg5config ( config : ImmutableConfig ) -> None : \"\"\" Helper for generating the madgraph configs. Replaces mg5creator.py. \"\"\" old_versions = [ \"2.4.3\" , \"2.3.3\" ] is_old_version = False if any ( version in config [ \"madgraph\" ][ \"version\" ] for version in old_versions ): is_old_version = True log . warning ( \"Old madgraph version detected: %s \" , config [ \"madgraph\" ][ \"version\" ]) output_path = ( Path ( config [ \"base\" ][ \"path\" ]) . joinpath ( config [ \"base\" ][ \"output\" ]) . resolve () ) output_path . mkdir ( parents = True , exist_ok = True ) # Ensure pythia card exists _pythia_card_path = Path ( config [ \"base\" ][ \"pythia_path\" ]) . joinpath ( config [ \"pythia\" ][ \"card\" ] ) if not _pythia_card_path . exists (): log . error ( \" %s does not exist.\" , _pythia_card_path ) sys . exit ( 1 ) # Controls whether to run Pythia8 or not pythia_config_path = \"\" pythia_onoff = \"OFF\" if not config [ \"pythia\" ][ \"skip\" ]: # Copy the pythia card pythia_card_path = ( Path ( config [ \"base\" ][ \"pythia_path\" ]) . joinpath ( config [ \"pythia\" ][ \"card\" ]) . resolve () ) new_pythia_card_path = output_path . joinpath ( \"pythia_card.dat\" ) # block below replaces a straightforward copy of pythia card to run area with open ( new_pythia_card_path , \"w\" , encoding = \"utf-8\" ) as new_pythia_card : with open ( pythia_card_path , encoding = \"utf-8\" ) as pcard : for line in pcard : # now handle specific pythia options. can be refactored later to be more elegant. # really only turning MPI on/off at the moment if \"partonlevel:mpi\" in line and \"mpi\" in config [ \"pythia\" ]: if config [ \"pythia\" ][ \"mpi\" ] == \"on\" : new_pythia_card . write ( \"partonlevel:mpi = on\" ) elif config [ \"pythia\" ][ \"mpi\" ] == \"off\" : new_pythia_card . write ( \"partonlevel:mpi = off\" ) else : log . error ( \"partonlevel:mpi can only be 'on' or 'off', not %s \" , config [ \"pythia\" ][ \"mpi\" ], ) sys . exit ( 1 ) else : new_pythia_card . write ( line ) if \"additional_opts\" in config [ \"pythia\" ]: new_pythia_card . write ( \" \\n \" ) new_pythia_card . write ( config [ \"pythia\" ][ \"additional_opts\" ]) log . info ( \"Pythia Card: %s \" , new_pythia_card_path ) pythia_onoff = \"Pythia8\" pythia_config_path = f \"/data/ { new_pythia_card_path . name } \" substitution = dict ( ecms = float ( config [ \"madgraph\" ][ \"ecms\" ]) / 2 , nevents = int ( config [ \"madgraph\" ][ \"nevents\" ]), iseed = int ( config [ \"madgraph\" ][ \"seed\" ]), ) masses = config [ \"madgraph\" ] . get ( \"masses\" , {}) if any ( key in masses for key in substitution ): raise ValueError ( \"Particles cannot be named ecms, nevents, or iseed.\" ) substitution . update ( masses ) log . info ( \"The following values will be substituted in where possible:\" ) for key , value in substitution . items (): log . info ( \" $ %s = %s \" , key , value ) # Update the param card param_card_path = ( Path ( config [ \"base\" ][ \"param_path\" ]) . joinpath ( config [ \"madgraph\" ][ \"paramcard\" ]) . resolve () ) new_param_card_path = output_path . joinpath ( param_card_path . name ) log . info ( \"Param Card: %s \" , new_param_card_path ) new_param_card_path . write_text ( Template ( param_card_path . read_text ( encoding = \"utf-8\" ), undefined = StrictUndefined ) . render ( substitution ), encoding = \"utf-8\" , ) # Update the run card run_card_path = ( Path ( config [ \"base\" ][ \"run_path\" ]) . joinpath ( config [ \"madgraph\" ][ \"run\" ][ \"card\" ]) . resolve () ) if is_old_version : log . warning ( \"Changing the run card due to old madgraph version.\" ) run_card_path = run_card_path . parent . joinpath ( \"default_LO_oldformat.dat\" ) new_run_card_path = output_path . joinpath ( run_card_path . name ) log . info ( \"Run Card: %s \" , new_run_card_path ) # -- first do global opts new_run_card_path . write_text ( Template ( run_card_path . read_text ( encoding = \"utf-8\" ), undefined = StrictUndefined ) . render ( substitution ), encoding = \"utf-8\" , ) # -- now specific opts. may want to reverse this order at some point, and do the specific before global. # Note: this will only work with options in the run card that contain a \"!\" in the line, indicating a comment at the end of the line. run_options = { ** config [ \"madgraph\" ][ \"run\" ] . get ( \"options\" , {})} # env = Environment() # parsed_content = env.parse('my text here') # tpl_variables = meta.find_undeclared_variables(parsed) pattern = re . compile ( r \"^\\s*(?P<value>[^\\s]+)\\s*=\\s*(?P<key>[a-z_0-9]+)\\s*\\!.*$\" , re . DOTALL ) with in_place . InPlace ( new_run_card_path ) as fpointer : for line in fpointer : match = pattern . match ( line ) if match : groups = match . groupdict () span = match . span ( \"value\" ) newvalue = str ( run_options . pop ( groups [ \"key\" ], groups [ \"value\" ])) # update the line based on input from the user, default to what is in the file line = line [: span [ 0 ]] + newvalue + line [ span [ 1 ] :] if not newvalue == groups [ \"value\" ]: log . info ( \" replacing value for %s : %s -> %s \" , groups [ \"key\" ], groups [ \"value\" ], newvalue , ) fpointer . write ( line ) unused_keys = list ( run_options . keys ()) if unused_keys : log . error ( \"Unused keys supplied by you: %s \" , unused_keys ) raise KeyError ( unused_keys [ 0 ]) # Copy the proc card proc_card_path = ( Path ( config [ \"base\" ][ \"process_path\" ]) . joinpath ( config [ \"madgraph\" ][ \"proc\" ][ \"card\" ]) . resolve () ) new_proc_card_path = output_path . joinpath ( proc_card_path . name ) log . info ( \"Process Card: %s \" , new_proc_card_path ) shutil . copyfile ( proc_card_path , new_proc_card_path ) # Create the madgraph configuration card mgconfig_card_path = output_path . joinpath ( config [ \"madgraph\" ][ \"generator\" ][ \"output\" ]) log . info ( \"MadGraph Config: %s \" , mgconfig_card_path ) # Figure out the run_mode. 0=single core, 1=cluster, 2=multicore. if config [ \"madgraph\" ][ \"batch\" ]: run_mode = \"set run_mode 0\" # we don't have MadGraph launch cluster jobs for us, we handle that ourselves. elif int ( config [ \"madgraph\" ][ \"cores\" ]) > 0 : run_mode = f \"set run_mode 2 \\n set nb_core { config [ 'madgraph' ][ 'cores' ] } \" else : run_mode = f \"set run_mode 2 \\n set nb_core { multiprocessing . cpu_count () / 2 } \" # figure out if running with madspin or not, and if so, put the card in the right place madspin_onoff = \"OFF\" madspin_config_path = \"\" if not config [ \"madspin\" ][ \"skip\" ]: # Copy the madspin card madspin_card_path = ( Path ( config [ \"base\" ][ \"madspin_path\" ]) . joinpath ( config [ \"madspin\" ][ \"card\" ]) . resolve () ) new_madspin_card_path = output_path . joinpath ( \"madspin_card.dat\" ) # block below replaces a straightforward copy of madspin card to run area, # but allows us to modify the card according to config options with open ( new_madspin_card_path , \"w\" , encoding = \"utf-8\" ) as new_madspin_card : with open ( madspin_card_path , encoding = \"utf-8\" ) as pcard : for line in pcard : # now handle specific madspin options. can be refactored later # to be more elegant. really only changing the spinmode at the moment if \"set spinmode\" in line and \"spinmode\" in config [ \"madspin\" ]: new_madspin_card . write ( f \"set spinmode { config [ 'madspin' ][ 'spinmode' ] } \\n \" ) else : new_madspin_card . write ( line ) log . info ( \"MadSpin Card: %s \" , new_madspin_card_path ) madspin_onoff = \"ON\" madspin_config_path = f \"/data/ { new_madspin_card_path . name } \" mg5config = f \"\"\" { run_mode } launch PROC_madgraph madspin= { madspin_onoff } shower= { pythia_onoff } reweight=OFF { madspin_config_path } /data/ { new_param_card_path . name } /data/ { new_run_card_path . name } { pythia_config_path } set iseed { config [ 'madgraph' ][ 'seed' ] } done \"\"\" if is_old_version : mg5config = f \"\"\" { run_mode } launch PROC_madgraph madspin= { madspin_onoff } reweight=OFF { madspin_config_path } /data/ { new_param_card_path . name } /data/ { new_run_card_path . name } done \"\"\" with mgconfig_card_path . open ( mode = \"w\" , encoding = \"utf-8\" ) as fpointer : for proc_line in new_proc_card_path . open ( encoding = \"utf-8\" ): if not proc_line . strip (): continue if proc_line . startswith ( \"output\" ): proc_line = \"output PROC_madgraph \\n \" fpointer . write ( proc_line ) fpointer . write ( mg5config )","title":"generate_mg5config()"}]}